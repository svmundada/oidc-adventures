# OIDC Adventures in Kubernetes Land

## What is OIDC ?
OIDC: OpenId Connect. It is a authentication/authorisation protocol based on oauth 2.0 flows.

## Why does it matter for kubernetes ?
- Users can present a token obtained from OIDC flows to APIServer to show their identitity and thus helps in authentication
- API Server can act as Identitity provider and issue tokens (not fully compliant as OIDC) which can be used by third parties (relying parties in OIDC) to authenticate those requests issued by API Server

## API Server as Identitiy provider

On request, Kubernetes can mount a token on pod's filesystem (unique to Pod). This token can be sent to third parties for authentication to some third party resource. Third parties can verify this token by reaching to API Server directly or indirectly.

This is very powerful pattern and it has been utilized at so many places for eg:
- [ack-controllers](https://aws-controllers-k8s.github.io/community/) (Provision AWS resources as Kuberentes YAML)
- [Zero-friction “keyless signing” with Kubernetes](https://blog.chainguard.dev/zero-friction-keyless-signing-with-kubernetes/) (Sign container images with trusted service accounts!)

To summarise:
> Provides a general framework for any third party service to validate - if requests are coming from an already trusted kuberentes cluster.

Mouting of this token is not a GA feature so it has to be enabled as feature flag in apiserver. This feature is called "Projected Service Account Tokens". Kubelet periodically refreshes the token on pod's filesystem.

Token is a JWT, which follows the structure of `id_token` from OIDC spec. This token is signed by apiserver's (identitity provider) private key (when it issues the token) and can be verified by apiserver's public keys (which are made public by apiserver, because they are public)

Example of JWT:
```
{
  "header": {
    "alg": "RS256",
    "kid": "u0QZNcjARrUBV4YKGQ8ihQJr1s8pofbSuunQ2nta6EU"
  },
  "payload": {
    "aud": [
      "adventures"
    ],
    "exp": 1638118755,
    "iat": 1638118155,
    "iss": "https://kubernetes.default.svc:443",
    "kubernetes.io": {
      "namespace": "default",
      "pod": {
        "name": "client",
        "uid": "be459051-d470-487c-b0d1-553939f086ac"
      },
      "serviceaccount": {
        "name": "default",
        "uid": "897b12c9-281d-41bc-b587-b17730f7bf1b"
      }
    },
    "nbf": 1638118155,
    "sub": "system:serviceaccount:default:default"
  },
  "signature": "LxYP6oZMjy5UG5ErRc1frxrusytYSUmzt24EgMEgakOU4EDv-lDYvBnGwFOTsXOhLbMnaOj6fsGrYEwN0Djg3k6tQpMDA7FHhcrbXGrz7QVwlTqcxQqp2m-MgiPJhp-i7ATLethsB3cnM-dUgd0mjpk3PNi8-9pFeybPaH29jTegwUUb1xpfONft-ZhToN4kDjKLe1pcLqjGlurhgOry1avmg37MPDVrQWLpG3qR5nqR8DK9JFsZ2GCLAj9wyHBJMWUq5h-O0EkAupOwxD0LYfeVqg4udMaVO-rivfCC5XSuinq1KiIx2FReUt-HxvToeTEpn7N-bwDf52FQBmWfXg"
}

```

Interesting fields:
1. `iss`: Who issued this token (issuer url as per oidc spec)
2. `exp`: it's unix epoch showing expiry time which means these are ephemeral tokens
3. `sub`: subject, whose identity is asserted by apiserver
4. `signature`: My fav part, this string is generated by apiserver's private key for payload, so it can be verified by third party using apiserver's public key. `header` field tells third party what crypto parameters would be required during verification like `alg` alogrithm and `kid` keyId. For more information on these parameters read [this](https://redthunder.blog/2017/06/08/jwts-jwks-kids-x5ts-oh-my/)

## How API Server exposes it's public key ?

OIDC (again!) defines a [spec](https://openid.net/specs/openid-connect-discovery-1_0.html) for discovering public information required in "validation" for third parties

# Simple Example

To understand bit more on details, we can create a client and server, where client authenticates to server by OIDC token.
Client gets oidc token from filesystem (mounted by kubelet, which get's it signed by issuer) and sends this token as header to server to present it's identity. Server validates this token by verifying signature on the token using issuer's public key.

## Understanding k8s setup

We rely on Kubernetes' API-Server as issuer for the JWTs, hence we need to provide some configuration values for the same. 

```
  apiServer:
    extraArgs:
      service-account-issuer: https://kubernetes.default.svc:443
      service-account-jwks-uri: https://kubernetes.default.svc:443/openid/v1/jwks
      service-account-signing-key-file: /etc/kubernetes/pki/sa.key
      service-account-key-file: /etc/kubernetes/pki/sa.pub  
```
`service-account-issuer`: As per OIDC spec, which entity is the issuer, in our case we keep it has api-server's incluster url.

`service-account-jwks-uri`: As per OIDC spec, validators reach to specific path on the `issuer` which is `/openid/v1/jwks` for finding public keys required to validate the OIDC token.

`service-account-signing-key-file`: Private key to used by API-Server while signing JWTs, here we are taking a shortcut and using already present key value pair. This is the private part.

`service-account-key-file`: This is the public part used for verification of JWTs.


As mentioned before, Projected Service Account Tokens is beta feature which needs to be explicity enabled, if your cluster does not support it (v1.20 was GA). 


## Understanding server
Server only accepts requests which have valid JWT present in `Authorization` Header. To validate the jwt token, server needs to know `ISSUER_URL` (although not necessary it can be extracted from JWT as well) and the oidc audience for which server accepts the token. 
```
      name: server
      env:
        - name: ISSUER_URL
          value: https://kubernetes.default.svc:443
        - name: OIDC_INTENDED_AUDIENCE
          value: adventures
```
Server obtains public keys from API-Server inorder to validate the incoming JWTs from request. To obtain public key information from API-Server we need to authorise this action by: 
```
kubectl create clusterrolebinding oidc-reviewer \
--clusterrole=system:service-account-issuer-discovery \
--group=system:unauthenticated
```
We simply attach unauthenicated group a simple, predefined  `system:service-account-issuer-discovery` clusterrole which will allow everyone to access this `/.well-known/openid-configuration` path on api-server


Upon successful validation, server returns `202`
## Understanding client
Client needs to tell kubelet about mounting JWTs, which happens by following snippet. Moreover, we can specify few properties about the JWT like `exp` and `aud`
```
  volumes:
    - name: oidc-token
      projected:
        sources:
          - serviceAccountToken:
              path: oidc-token
              expirationSeconds: 600
              audience: adventures
```
Next we specify the exact path where this projected service account can be mounted:
```
      volumeMounts:
        - mountPath: /var/run/secrets/tokens
          name: oidc-token
```
We also specify the server in env var `OIDC_REQUIRED_SERVER` for client to connect.
Client will use this JWT from filesystem (`/var/run/secrets/tokens/oidc-token`) for making requests to server.



## Steps to run this project:

1. `bash kind-cluster.sh`. This sets up the k8s-cluster, docker registry and required OIDC settings.  
2. Make sure local registry is up and running by `curl -vk localhost:5000/v2/_catalog`
3. Build client and server.
  - `export KO_DOCKER_REPO=localhost:5000/oidc-adventures`
  - `ko publish ./cmd/client -t v2`
  - `ko publish ./cmd/server -t v2`
4. Deploy client and server
  - `kubectl config use-context kind-kind`
  - `kubectl apply -f config/`
5. check logs
  - `kubectl logs client -f`
  - Another terminal window `kubectl logs server -f`
6. For fun, try changing `audience` parameter is either server or client to see what happens.
7. For fun, try deleting `oidc-reviewer` clusterrolebinding.

# References:
- https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection
- https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-issuer-discovery
- https://banzaicloud.com/blog/kubernetes-oidc/ 

